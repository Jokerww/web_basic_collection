<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
		<!-- JS的执行机制：
		1，JS是单线程语言，同一个时间只能做一件事。对页面的交互操作不能同时进行
			单线程就意味着 存在多个任务时 任务需要排队执行
			问题：当某一个任务花费时间较长时 会导致整个JS执行时间过长 
				导致页面渲染不连贯 加载阻塞
		2，同步和异步：HTML5允许JS脚本创建多个线程 于是JS中出现了同步和异步
			同步：前一个任务执行完了 后一个任务再执行 执行顺序与任务排列顺序一致
			异步：当做某一件事情花费的时间较长时 可以先去执行其他的任务
			区别：流水线上各个线程的执行顺序不同
		3，执行栈和消息队列：
			HTML5中 JS任务分为同步任务和异步任务
				同步任务：当前JS中 任务流程上的任务
				异步任务：JS的异步是通过回调函数实现的 有三类
					普通事件：如click resize等
					资源加载事件：load error等
					定时器函数：setInterval()、setTimeout()等
			
			同步任务在主线程上执行 形成一个执行栈
			异步任务将等待异步进程处理 在任务触发时异步进程将该任务放入消息队列中
				当主线程的同步任务全部执行完后 会将消息队列中的任务获取至主线程执行栈
				然后执行 不断重复 读取任务 执行 的过程 称为事件循环
				
		4，当在执行主线程的任务遇到含有回调函数的任务时 先将回调函数交给异步处理进程
			并不执行 然后继续执行主线程执行栈的任务 执行栈的任务处理完之后 
			再去看看消息队列里边有没有任务 有任务的话 就获取放到执行栈 执行
			会重复检测消息队列里边有有没有任务并拿来执行 即事件循环过程
			而只有当异步任务被触发时(定时时间到了或者点击了按钮) 他才会被放入消息队列
		 -->
		 
		 <script type="text/javascript">
		 	console.log(1);
			// 就算等待时间为0 里边的回调函数还是得放在消息队列里 
			// 等主线程完了 才执行
			setTimeout(function(){console.log(2)},0);
			// 回调函数只有等鼠标点击了之后才会放在消息队列里 然后执行
			window.addEventListener('click',function(){console.log(3);});
			console.log(4);
		 </script>
	</body>
</html>
